# -*- coding: utf-8 -*-
"""Findind_Path_Level_3_4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1toP6MMxMnBf1GvOUP8IwT1BTTNqif5nP

#Import package
"""

from collections import deque
import heapq
import numpy as np
from functools import reduce
import operator
import math
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
SCREEN_TITLE = "Shortest path"

"""#Read data from text files"""

def read_file(path):
  with open(path) as input_file:
      '''
      Testing
      width, height, start, end, pick_up_points, new_polygons = read_file('/content/input_0.txt')
      '''
      # Get all lines from input file
      lines = [line for line in input_file]
    
      # Convert line to attribute
      width, height = [int(x) for x in lines[0].split()]
      
      # Get start, end point 
      points = [int(x) for x in lines[1].split()]
      length = len(points)
      x = [points[i] for i in range(length) if i % 2 == 0]
      y = [points[i] for i in range(length) if i % 2 == 1]
    
      start = (x[0], y[0])
      end = (x[1], y[1])
      pick_up_points = [(x[i], y[i]) for i in range(2, length//2)]
    
      # Get number of polygons
      number_of_polygons = int(lines[2]) 
    
      # Get polygons
      polygons = [[int(x) for x in lines[i].split()] for i in range(3, 3 + number_of_polygons)]
      
      # Convert type of polygons from list of list to list of list of tuple
      new_polygons = []
      for polygon in polygons:
        temp_polygon = []
      
        for i in range(len(polygon)):
          if i % 2 == 0:
            x = polygon[i]
          
          if i % 2 == 1:
            y = polygon[i]
            temp_polygon.append((x, y))
          
        new_polygons.append(temp_polygon)
        
 
  return width, height, start, end, pick_up_points, new_polygons

width, height, start, end, pick_up_points, new_polygons = read_file('/content/input_0.txt')

print(width, height, start, end, pick_up_points, new_polygons)

"""#Create priority queue"""

class PriorityQueue:
    def __init__(self):
        self.elements = []
    #Checking priority queue is empty
    def empty(self):
        return len(self.elements) == 0

    # Push item with priority into queue
    def put(self, item, priority):
        heapq.heappush(self.elements, (priority, item))
    
    # Pop and get first item out of queue
    def get(self):
        return heapq.heappop(self.elements)[1]

"""#Create graph 2D"""

class Graph2D :
  def __init__(self,width,height) : 
    self.width  = width
    self.height = height
    self.polygons = []
    self.coordinate = [ [ 0 for x in range(0,width)] for y in range(0,height)]
    self.direct = [ [0,-1],[0,1],[-1,0],[1,0]]

  def set_state(self,point) :
    x,y = point
    self.coordinate[y][x] = 1 - self.coordinate[y][x]

  def get_state(self,x,y) :
    return self.coordinate[y][x] 

  def out_of_bounds(self,x,y) :
    return not (0< x and x < self.width and 0 < y and y < self.height)
  
  def clockwise(self,coords):
    center = tuple(map(operator.truediv, reduce(lambda x, y: map(operator.add, x, y), coords), [len(coords)] * 2))
    return sorted(coords, key=lambda coord: (-135 - math.degrees(math.atan2(*tuple(map(operator.sub, coord, center))[::-1]))) % 360)

  def points_to_polygon(self,points):
    polygon = []
    number_of_points = len(points)
    for i in range(0,number_of_points):
			# current point
      x1,y1 = points[i]

      # next point
      x2,y2 = points[0] if (i+1 >= number_of_points) else points[i+1]
			
      # if there is a x-axis line
      if(x1 == x2):
        for y in range(min([y1,y2]),max([y1,y2])+1):
          polygon.append((x1,y))
      else:
        a=(y2-y1)/(x2-x1)
        b=(int)(y1-x1*a)
        for x in range(min([x1,x2]),max([x1,x2])+1):
          polygon.append((x,int(x*a+b)))

    polygon = self.clockwise( list(set(polygon)) )
    return polygon

  def points_to_polygons(self,points):
    polygons = []
    for p in points:
      polygons.append(self.points_to_polygon(p))
    return polygons

  def polygons_to_coordinate(self,polygons):
    coordinate = [ [ 0 for x in range(0,self.width)] for y in range(0,self.height)]
    self.polygons = self.points_to_polygons(polygons)
    for polygon in self.polygons:
      for (x,y) in polygon :
        coordinate[y][x] = 1
    self.coordinate = coordinate
  
  def get_neighbors(self,current):
    neighbors = []
    for i in range(0,4) :
      x,y = self.direct[i][0]+current[0], self.direct[i][1]+current[1]
      if( not self.out_of_bounds(x,y) and self.get_state(x,y)!=1 ):
        neighbors.append((x,y))
    return neighbors

  def printGraph(self) : 
    print (self.coordinate)

"""#Create shortest path"""

class ShortestPath : 
  def __init__(self,graph2D) :
    self.graph2D = graph2D

  def backtrace(self,parent,start,end) :
    if not parent[end]:
      return None
    path = [end]
    while path[-1] != start:
      path.append(parent[path[-1]])
    path.reverse()
    return path
  
  def heuristic(self, a, b):
    (x1, y1) = a
    (x2, y2) = b
    return abs(x1 - x2) + abs(y1 - y2)

  def a_star_search(self, start, goal):
    #Push start into frontier
    frontier = PriorityQueue()
    frontier.put(start, 0)
    
    # Create a dictionary that contains previous position of current position   
    parent = {}
    # Create a dictionary that contains cost_so_far[current_position] = sum up cost from start to current_position
    cost_so_far = {}
    
    # Initilization dictionary 
    parent[start] = None
    parent[end] = None
    cost_so_far[start] = 0

    while not frontier.empty():
        # Get position from front positions (previous position)
      current = frontier.get()

      # If you are standing at goal to stop
      if current == goal:
        break

      # Get adjacent vertices
      for next in self.graph2D.get_neighbors(current):
        #Update new_cost 
        new_cost = cost_so_far[current] + 1
        # Checking is in cost_so_far or new_cost is smaller than old_cost
        if next not in cost_so_far or new_cost < cost_so_far[next]:
          #Update new cost
          cost_so_far[next] = new_cost
          priority = new_cost + self.heuristic(goal, next)
          #Update frontier and parent
          frontier.put(next, priority)
          parent[next] = current
    return self.backtrace(parent, start, goal)

  # BFS
  def BFS(self,start,end) :
    queue = deque([])
    queue.append(start)
    parent = {}
    parent[start] = None
    parent[end] = None
    graph2D = self.graph2D

    graph2D.set_state(start)

    while queue : 
      current = queue.popleft()
      if(current == end): 
        break

      for next in self.graph2D.get_neighbors(current):
        graph2D.set_state(next)
        queue.append(next)
        parent[next] = (current)
    return self.backtrace(parent,start,end)

  #DFS
  def DFS(self,start,end):
    path=[]
    queue=[start]
    while (queue):
      current=queue.pop(0)
      path.append(current)
      if(current == end):
        break
      self.graph2D.set_state(current)
      for next in self.graph2D.get_neighbors(current):
        queue.insert(0,next)
    return path

"""#Run Code"""

width,height, start, end, pick_up_points, polygons = read_file("input_0.txt")

graph2D = Graph2D(width + 1,height + 1)
graph2D.polygons_to_coordinate(polygons)

shortestPath = ShortestPath(graph2D)

path =  shortestPath.a_star_search( start,(3, 3))
if(path != -1) :
  print(len(path) - 1)
  print(path)
else :
  print("No solution")

pick_up_points

path =  shortestPath.a_star_search(start, end)
if(path != -1) :
  print(len(path) - 1)
  print(path)
else :
  print("No solution")

def heuristic(a, b):
  (x1, y1) = a
  (x2, y2) = b
  return abs(x1 - x2) + abs(y1 - y2)

pick_up_points

def create_list(pick_up_points, start, end):
  result = [start]
  points = list(pick_up_points)
  
  while len(points) != 0:
    # Init variables
    point_min = points[0]
    min_value = heuristic(result[-1], point_min)
    
    for point in points:
      # Find point that has heuristic(result[-1], point) is minimum
      if heuristic(result[-1], point) < min_value:
        point_min = point
        min_value = heuristic(result[-1], point)
    
    # Update point_list
    result.append(point_min)
    # Deleted Out of pick_up points
    points.remove(point_min)
    
  # Add end point
  result.append(end)
  
  return result

def create_path(pick_up_points, start, end):
  point_list = create_list(pick_up_points, start, end)
  result = []
  
  # Find first period
  path =  shortestPath.a_star_search(point_list[0], point_list[1])
  if path != -1:
    result = path
  else:
    return -1
  
  length = len(point_list)
  for i in range(1, length - 1):
    path =  shortestPath.a_star_search(point_list[i], point_list[i + 1])
    
    if path != -1:
      for i in range(1, len(path)):
        result.append(path[i])
    else:
      return -1
    
  return result

point_list = create_list(pick_up_points, start, end)

point_list

pick_up_points

create_path(pick_up_points, start, end)

